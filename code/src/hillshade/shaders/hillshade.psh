struct constants
{
    float4x4 view_proj;
    float4 bounds;
    float4 terrain_resolution;
    float4 albedo;
    float3 light_dir;
    float ambient_intensity;
    float exaggeration;
};

Texture2D       g_terrain;
SamplerState    g_terrain_sampler;

cbuffer PSConstants
{
    constants g_pconstants;
};

struct PSInput
{ 
    float4 pos  : SV_POSITION; 
    float2 uv   : TEX_COORD; 
};

struct PSOutput
{ 
    float4 color : SV_TARGET; 
};

float3 normal_at(float2 uv, float4 bounds, float4 res)
{
    float step = 0.5 * res.z;    // step is half a texel in the x direction

    // compute uv coords
    float2 east_uv  = uv + float2(step, 0);
    float2 west_uv  = uv - float2(step, 0);
    float2 north_uv = uv - float2(0, step);
    float2 south_uv = uv + float2(0, step);

    // sample elevation vlaues
    float east_z  = g_terrain.Sample(g_terrain_sampler, east_uv).r;
    float west_z  = g_terrain.Sample(g_terrain_sampler, west_uv).r;
    float north_z = g_terrain.Sample(g_terrain_sampler, north_uv).r;
    float south_z = g_terrain.Sample(g_terrain_sampler, south_uv).r;

    // compute normal vector
    float delta = step * (bounds.z - bounds.x);
    float3 normal = float3(east_z - west_z, north_z - south_z, 2.0 * delta);
    return normalize(normal);
}

float3 hillshade(float3 albedo, float3 light_dir, float ambient_intensity, float3 normal, float exaggeration)
{
    normal = normalize(float3(exaggeration * normal.xy, normal.z));
    float strength = 0.5 * (1.0 - dot(normal, light_dir));
    return (ambient_intensity + (1 - ambient_intensity) * strength) * albedo;
}

void main(in PSInput pixel_input, out PSOutput pixel_output)
{
    float3 normal = normal_at(pixel_input.uv, g_pconstants.bounds, g_pconstants.terrain_resolution);
    float3 shading = hillshade(g_pconstants.albedo.rgb, g_pconstants.light_dir, g_pconstants.ambient_intensity, normal, g_pconstants.exaggeration);
    pixel_output.color = float4(shading, 1.0);
}